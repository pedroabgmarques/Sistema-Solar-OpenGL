
#include "Solar.h"   
#include <stdlib.h> 

#include <GL/glut.h>	

static GLenum spinMode = GL_TRUE;
static GLenum singleStep = GL_FALSE;

// Controlo do estado e velocidade das animacoes
static float HourOfDay = 0.0;
static float DayOfYear = 0.0;
static float HourOfDay2 = 0.0;
static float DayOfYear2 = 0.0;
static float HourOfDay3 = 0.0;
static float DayOfYear3 = 0.0;
static float HourOfDay4 = 0.0;
static float DayOfYear4 = 0.0;
static float HourOfDay5 = 0.0;
static float DayOfYear5 = 0.0;
static float HourOfDay6 = 0.0;
static float DayOfYear6 = 0.0;
static float HourOfDay7 = 0.0;
static float DayOfYear7 = 0.0;
static float HourOfDay8 = 0.0;
static float DayOfYear8 = 0.0;

static float AnimateIncrement = 24.0;  // tempo para animacoes (horas)


static void KeyPressFunc( unsigned char Key, int x, int y )
{
	switch ( Key ) {//isto das teclas fui buscar a net, se quiseres tira,tao a funciunar
	case 'R':
	case 'r':
		Key_r();
		break;
	case 's':
	case 'S':
		Key_s();
		break;
	case 27:	// tecla esc
		exit(1);
	}
}


static void SpecialKeyFunc( int Key, int x, int y )
{
	switch ( Key ) {
	case GLUT_KEY_UP:		
		Key_up();
		break;
	case GLUT_KEY_DOWN:
		Key_down();
		break;
	}
}


static void Key_r(void)
{
	if ( singleStep ) {			
		singleStep = GL_FALSE;
		spinMode = GL_TRUE;		// da restard a animacao
	}
	else {
		spinMode = !spinMode;	// liga e desliga a animaçao
	}
}

static void Key_s(void)
{
	singleStep = GL_TRUE;
	spinMode = GL_TRUE;
}

static void Key_up(void)
{
    AnimateIncrement *= 1.5;			// duplica a velocidade da animaçao
}

static void Key_down(void)
{
    AnimateIncrement /= 2.0;			// reduz a velocidade da animaçao
	
}


static void Animate(void)
{
	// limpa a janela
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (spinMode) {
		// update da animaçao
        HourOfDay += AnimateIncrement;
        DayOfYear += AnimateIncrement/30.0;

        HourOfDay = HourOfDay - ((int)(HourOfDay/24))*24;
        DayOfYear = DayOfYear - ((int)(DayOfYear/365))*365;

		HourOfDay2 = HourOfDay2 - ((int)(HourOfDay2 / 36)) * 36;
		DayOfYear2= DayOfYear2 - ((int)(DayOfYear2 / 400)) * 400;
		
		HourOfDay3 = HourOfDay3 - ((int)(HourOfDay3 / 36)) * 36;
		DayOfYear3 = DayOfYear3 - ((int)(DayOfYear3 / 400)) * 400;
		
		HourOfDay4 = HourOfDay4 - ((int)(HourOfDay4 / 36)) * 36;
		DayOfYear4 = DayOfYear4 - ((int)(DayOfYear4 / 400)) * 400;

		HourOfDay5 = HourOfDay5 - ((int)(HourOfDay5 / 36)) * 36;
		DayOfYear5 = DayOfYear5 - ((int)(DayOfYear5 / 400)) * 400;

		HourOfDay5 = HourOfDay6 - ((int)(HourOfDay5 / 36)) * 36;
		DayOfYear5 = DayOfYear6 - ((int)(DayOfYear5 / 400)) * 400;

		HourOfDay5 = HourOfDay7 - ((int)(HourOfDay5 / 36)) * 36;
		DayOfYear5 = DayOfYear7 - ((int)(DayOfYear5 / 400)) * 400;

		HourOfDay5 = HourOfDay8 - ((int)(HourOfDay5 / 36)) * 36;
		DayOfYear5 = DayOfYear8 - ((int)(DayOfYear5 / 400)) * 400;
		}

    glLoadIdentity();

	// reduz 8 unidades para ver da origem
    glTranslatef ( 0.0, 0.0, -10.0 );

	//roda o plano epiliticamente
	// (roda sobreo x do modelo em 15 graus)
	glRotatef( 180.0, 1.0, 0.0, 0.0 );

    // desenhar sol	-- amarelo em wireframe
	glRotatef(360.0*DayOfYear / 365.0, 0.0, 1.0, 0.0);
	glColor3f( 1.0, 1.0, 0.0 );			
    glutWireSphere( 1.0, 15, 15 );

    // desenha terra
	// 1 pos a volta do sol
	//		usa o dia do ano para determinar a sua posicao
    glRotatef( 360.0*DayOfYear2/365.0, 1.0, 1.0, 0.0 );
    glTranslatef( 4.0, 0.0, 0.0 );
    glPushMatrix();						// guarda o estado da matrix
	// roda a terra sobre o seu eixo
	//		usa a hora do dia para determinar a sua posicao
	glRotatef( 24.0*HourOfDay/24.0, 0.0, 1.0, 0.0 );
	// desenha a terra numa esferea em wireframe
    glColor3f( 0.2, 0.2, 1.0 );
    glutWireSphere( 0.4, 20, 20);


	//2 planeta
	glRotatef(480*DayOfYear2 / 480.0, 1.0, 1.0, 0.0);
	glTranslatef(10.0, 0.0, 0.0);
	glPushMatrix();						
	glRotatef(36*HourOfDay2 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 20, 20);
	
	//3 planeta
	glRotatef(480 * DayOfYear3 / 480.0, 1.0, 1.0, 0.0);
	glTranslatef(-8.0, 0.0, 0.0);
	glPushMatrix();
	glRotatef(36 * HourOfDay3 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 10, 10);

    glPopMatrix();			

	//4 planeta
	glRotatef(480 * DayOfYear4 / 480.0, 1.0, 1.0, 0.0);
	glTranslatef(7.0, 0.0, 0.0);
	glPushMatrix();
	glRotatef(36 * HourOfDay4 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 10, 10);

	glPopMatrix();

	//5 planeta
	glRotatef(480 * DayOfYear5 / 480.0, 1.0, 1.0, 0.0);
	glTranslatef(-4.0, 0.0, 0.0);
	glPushMatrix();
	glRotatef(36 * HourOfDay5 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 10, 10);

	glPopMatrix();


	//6 planeta
	glRotatef(480 * DayOfYear6 / 480.0, 1.0, 1.0, 0.0);	
	glTranslatef(-4.0, 0.0, 0.0);
	glPushMatrix();
	glRotatef(36 * HourOfDay6 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 10, 10);

	glPopMatrix();

	//7 planeta
	glRotatef(480 * DayOfYear7 / 480.0, 1.0, 1.0, 0.0);
	glTranslatef(-4.0, 0.0, 0.0);
	glPushMatrix();
	glRotatef(36 * HourOfDay7 / 36.0, 0.0, 1.0, 0.0);
	glColor3f(0.5, 0.2, 1.0);
	glutWireSphere(0.4, 10, 10);

	glPopMatrix();
	
	
	
	glPopMatrix();
	//desenha  a lua
	//usa a hora do dia para determinar a sua posicao

   	glRotatef( 360.0*12.0*DayOfYear/365.0, 0.0, 1.0, 0.0 );
    glTranslatef( 0.7, 0.0, 0.0 );
    glColor3f( 0.3, 0.7, 0.3 );
    glutWireSphere( 0.1, 5, 5 );

	// troca os buffers
    glFlush();
    glutSwapBuffers();

	if ( singleStep ) {
		spinMode = GL_TRUE;
	}

	glutPostRedisplay();	
	// pede um redraw para um proposito da animaçao

}

// Initialize OpenGL's rendering modes
void OpenGLInit(void)
{
    glShadeModel( GL_CLAMP );
    glClearColor( 0.0, 0.0, 0.0, 0.0 );
    glClearDepth( 1.0 );
    glEnable(GL_DEPTH_RANGE );
}


static void ResizeWindow(int w, int h)
{
    float aspectRatio;
	h = (h == 0) ? 1 : h;
	w = (w == 0) ? 1 : w;
	glViewport( 0, 0, w, h );	// View port usa uma janela inteira
	aspectRatio = (float)w/(float)h;

	// prepara a vista da matrix (nao muito bem!)
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity();
    gluPerspective( 100.0, aspectRatio, 1, 45.0 );

	// seleciona o modelo de vista da matrix
    glMatrixMode( GL_MODELVIEW );
}


//rota principal
int main( int argc, char** argv )
{
	
	glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH );


    glutInitWindowPosition( 0, 0 );
    glutCreateWindow( "Sistema Solar" );
	//glutInitWindowSize(1080, 1080);
	glutFullScreen();


    OpenGLInit();


	glutKeyboardFunc( KeyPressFunc );
	glutSpecialFunc( SpecialKeyFunc );

    glutReshapeFunc( ResizeWindow );

    glutDisplayFunc( Animate );
	

	glutMainLoop(  );

    return(0);			
}
